{"pages":[{"title":"","text":"{\"version\":\"Sample 1.0.0\",\"model\":\"moc/hijiki.moc\",\"textures\":[\"moc/hijiki.2048/texture_00.png\"],\"name\":\"hijiki\",\"pose\":\"hijiki.pose.json\",\"motions\":{\"idle\":[{\"file\":\"mtn/00_idle.mtn\"}],\"\":[{\"file\":\"mtn/01.mtn\"},{\"file\":\"mtn/02.mtn\"},{\"file\":\"mtn/03.mtn\"},{\"file\":\"mtn/04.mtn\"},{\"file\":\"mtn/05.mtn\"},{\"file\":\"mtn/06.mtn\"},{\"file\":\"mtn/07.mtn\"},{\"file\":\"mtn/08.mtn\"}]}}","link":"/live2d_models/live2d-widget-model-hijiki/assets/hijiki.model.json"},{"title":"","text":"{\"type\":\"Live2D Pose\",\"fade_in\":0,\"parts_visible\":[{\"group\":[{\"id\":\"PARTS_01_ARM_R\"},{\"id\":\"PARTS_01_ARM_R_02\"}]},{\"group\":[{\"id\":\"PARTS_01_ARM_L\"},{\"id\":\"PARTS_01_ARM_L_02\"}]}]}","link":"/live2d_models/live2d-widget-model-hijiki/assets/hijiki.pose.json"},{"title":"","text":"{\"name\":\"live2d-widget-model-hijiki\",\"version\":\"1.0.5\",\"description\":\"hijiki live2d model for live2d-widget.js\",\"scripts\":{\"test\":\"echo \\\"Error: no test specified\\\" && exit 1\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/xiazeyu/live2d-widget-models.git\"},\"license\":\"GPL-2.0\",\"bugs\":{\"url\":\"https://github.com/xiazeyu/live2d-widget-models/issues\"},\"homepage\":\"https://github.com/xiazeyu/live2d-widget-models#readme\"}","link":"/live2d_models/live2d-widget-model-hijiki/package.json"}],"posts":[{"title":"SpringBoot 使用 elasticsearch-java8.1.2 客户端","text":"由于自己在学 elasticsearch-java 客户端的 8.1.2 版本的时候由于网上教程很少，学的很吃力。所以决定自己写一篇博客来记录一下。 导入 jar 包pom.xml12345&lt;dependency&gt; &lt;groupId&gt;co.elastic.clients&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-java&lt;/artifactId&gt; &lt;version&gt;8.1.2&lt;/version&gt;&lt;/dependency&gt; 开始编写代码注入 esClient 的 Bean因为我们这个客户端对象需要多次使用，每次实例化再配置就很不方便。所以我们可以写一个 Configuration 来自动注入 springboot。 先来理一下我们需要干什么事情： 创建 Configuration 类 使用 ConfigurationProperties 实现自动读取 yaml 配置（因为 host 地址是容易变的） ElasticsearchConfig.java123456789101112131415161718192021222324252627282930313233/** * @author CHENPrime-coder &lt;chenbprime@outlook.com&gt; */@Configuration@ConfigurationProperties (prefix = &quot;es.config&quot;)public class ElasticsearchConfig { // 需要动态变化的 host 地址 public String esServerAddress = &quot;127.0.0.1&quot;; public String getEsServerAddress () { return esServerAddress; } public void setEsServerAddress (String esServerAddress) { this.esServerAddress = esServerAddress; } //esClient 的 Bean @Bean public ElasticsearchClient esClient () { // 1. 构造 RestClient，端口是 9200 RestClient client = RestClient.builder ( new HttpHost (esServerAddress, 9200) ).build (); // 2. json 转换配置，这里使用 Jackson ElasticsearchTransport transport = new RestClientTransport ( client, new JacksonJsonpMapper () ); // 3. 构造 ElasticsearchClient return new ElasticsearchClient (transport); }} 修改 application.yaml 配置文件使用 yaml 配置 host 地址，这里假设我们需要使用 docker 部署，所以修改为 es-server（容器名）。 application.yaml1234es: config: # 这里写上主机地址（host），也可以写 ip 地址（如：127.0.0.1） es-server-address: es-server 索引库操作首先我们先在 test 包下创建测试类 HotelIndexTest.java，开始测试客户端（Junit）。下面的代码中 beforeAll 方法和 afterAll 分别是初始化客户端和关闭客户端，使用原始的方式。这里我们使用 springboot 的自动注入 esClient。 我们先把代码的基本框架写好，再去写具体的凭借条件并查询 HotelIndexTest.java123456789101112131415161718192021222324252627282930313233343536373839@SpringBootTestpublic class HotelIndexTest { // 注入 esClient @Autowired static ElasticsearchClient esClient; // @BeforeAll //static void beforeAll () { // restClient = RestClient.builder ( // new HttpHost (&quot;192.168.118.10&quot;, 9200)).build (); // ElasticsearchTransport transport = new RestClientTransport ( // restClient, new JacksonJsonpMapper () // ); // // esClient = new ElasticsearchClient (transport); // } // @AfterAll //static void afterAll () throws IOException { // restClient.close (); // } // 创建索引库 @Test void createIndex () throws IOException { } // 删除索引库 @Test void deleteIndex () throws IOException { } // 判断索引库是否存在 @Test void existsIndex () throws IOException { }} elasticsearc-java 使用了大量的建造器模式，有各种各样的 Builder。并且需要一定的 lambda 基础，建议先学一下 lambda 再写代码 创建索引库既然是创建索引库，并且上面也讲了需要用 XXXBuilder 来构造查询语句。所以我们需要使用 CreateIndexRequest.Builder 来创建索引库 创建索引库既可以用 json 字符串创建，也可以使用 lambda 的方式创建。这里我们先使用 json 演示，我们需要先创建一个常量类包装 json 字符串。这里的 json 写法和 DSL 的写法是一样的，由于本文的重心并不是 DSL，所以这里就不赘述了 HotelConstants.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * @author CHENPrime-coder &lt;chenbprime@outlook.com&gt; */public class HotelConstants { public static final String MAPPING_TEMPLATE = &quot;{\\n&quot; + &quot;\\&quot;mappings\\&quot;: {\\n&quot; + &quot;\\&quot;properties\\&quot;: {\\n&quot; + &quot;\\&quot;id\\&quot;: {\\n&quot; + &quot;\\&quot;type\\&quot;: \\&quot;keyword\\&quot;\\n&quot; + &quot;},\\n&quot; + &quot;\\&quot;name\\&quot;: {\\n&quot; + &quot;\\&quot;type\\&quot;: \\&quot;text\\&quot;,\\n&quot; + &quot;\\&quot;analyzer\\&quot;: \\&quot;ik_max_word\\&quot;,\\n&quot; + &quot;\\&quot;copy_to\\&quot;: \\&quot;all\\&quot;\\n&quot; + &quot;},\\n&quot; + &quot;\\&quot;address\\&quot;: {\\n&quot; + &quot;\\&quot;type\\&quot;: \\&quot;keyword\\&quot;,\\n&quot; + &quot;\\&quot;index\\&quot;: false\\n&quot; + &quot;},\\n&quot; + &quot;\\&quot;price\\&quot;: {\\n&quot; + &quot;\\&quot;type\\&quot;: \\&quot;integer\\&quot;\\n&quot; + &quot;},\\n&quot; + &quot;\\&quot;score\\&quot;: {\\n&quot; + &quot;\\&quot;type\\&quot;: \\&quot;integer\\&quot;\\n&quot; + &quot;},\\n&quot; + &quot;\\&quot;brand\\&quot;: {\\n&quot; + &quot;\\&quot;type\\&quot;: \\&quot;keyword\\&quot;,\\n&quot; + &quot;\\&quot;copy_to\\&quot;: \\&quot;all\\&quot;\\n&quot; + &quot;},\\n&quot; + &quot;\\&quot;city\\&quot;: {\\n&quot; + &quot;\\&quot;type\\&quot;: \\&quot;keyword\\&quot;,\\n&quot; + &quot;\\&quot;copy_to\\&quot;: \\&quot;all\\&quot;\\n&quot; + &quot;},\\n&quot; + &quot;\\&quot;starName\\&quot;: {\\n&quot; + &quot;\\&quot;type\\&quot;: \\&quot;keyword\\&quot;,\\n&quot; + &quot;\\&quot;copy_to\\&quot;: \\&quot;all\\&quot;\\n&quot; + &quot;},\\n&quot; + &quot;\\&quot;business\\&quot;: {\\n&quot; + &quot;\\&quot;type\\&quot;: \\&quot;keyword\\&quot;,\\n&quot; + &quot;\\&quot;copy_to\\&quot;: \\&quot;all\\&quot;\\n&quot; + &quot;},\\n&quot; + &quot;\\&quot;location\\&quot;: {\\n&quot; + &quot;\\&quot;type\\&quot;: \\&quot;geo_point\\&quot;\\n&quot; + &quot;},\\n&quot; + &quot;\\&quot;pic\\&quot;: {\\n&quot; + &quot;\\&quot;type\\&quot;: \\&quot;keyword\\&quot;,\\n&quot; + &quot;\\&quot;index\\&quot;: false\\n&quot; + &quot;},\\n&quot; + &quot;\\&quot;all\\&quot;: {\\n&quot; + &quot;\\&quot;type\\&quot;: \\&quot;text\\&quot;,\\n&quot; + &quot;\\&quot;analyzer\\&quot;: \\&quot;ik_max_word\\&quot;\\n&quot; + &quot;}\\n&quot; + &quot;}\\n&quot; + &quot;}\\n&quot; + &quot;}&quot;; public static final String USER_MAPPING = &quot;{\\n&quot; + &quot;\\&quot;mappings\\&quot;: {\\n&quot; + &quot;\\&quot;properties\\&quot;: {\\n&quot; + &quot;\\&quot;info\\&quot;: {\\n&quot; + &quot;\\&quot;type\\&quot;: \\&quot;text\\&quot;,\\n&quot; + &quot;\\&quot;analyzer\\&quot;: \\&quot;ik_smart\\&quot;\\n&quot; + &quot;},\\n&quot; + &quot;\\&quot;email\\&quot;: {\\n&quot; + &quot;\\&quot;index\\&quot;: false,\\n&quot; + &quot;\\&quot;type\\&quot;: \\&quot;keyword\\&quot;\\n&quot; + &quot;},\\n&quot; + &quot;\\&quot;name\\&quot;: {\\n&quot; + &quot;\\&quot;type\\&quot;: \\&quot;object\\&quot;,\\n&quot; + &quot;\\&quot;properties\\&quot;: {\\n&quot; + &quot;\\&quot;firstName\\&quot;: {\\n&quot; + &quot;\\&quot;type\\&quot;: \\&quot;keyword\\&quot;\\n&quot; + &quot;},\\n&quot; + &quot;\\&quot;lastName\\&quot;: {\\n&quot; + &quot;\\&quot;type\\&quot;: \\&quot;keyword\\&quot;\\n&quot; + &quot;}\\n&quot; + &quot;}\\n&quot; + &quot;}\\n&quot; + &quot;}\\n&quot; + &quot;}\\n&quot; + &quot;}&quot;;} 然后我们就可以开始写具体的搜索请求了 HotelIndexTest.java1234567891011121314151617@Testvoid createIndex () throws IOException { // 以 ByteArrayInputStream 读入字符串 ByteArrayInputStream inputStream = new ByteArrayInputStream (USER_MAPPING.getBytes (StandardCharsets.UTF_8)); // 实例化建造器 CreateIndexRequest.Builder builder = new CreateIndexRequest.Builder (); // 设置索引库的名字 builder.index (&quot;user&quot;); // 使用 json 方式创建索引库 builder.withJson (inputStream); // 构造请求 CreateIndexRequest request = builder.build (); // 使用 esClient 测试请求并返回结果 System.out.println (esClient.indices ().create (request).acknowledged ());} 这里输出的 acknowledged 为 true 就说明索引库创建成功了，下面的 acknowledged 也同理 删除索引库索引库的删除操作十分简单，我们只需要指定索引库名称就可以实现索引库的删除 HotelIndexTest.java1234567@Testvoid deleteIndex () throws IOException { DeleteIndexRequest.Builder builder = new DeleteIndexRequest.Builder (); builder.index (&quot;user&quot;); System.out.println (esClient.indices ().delete (builder.build ()).acknowledged ());} 判断索引库是否存在判断索引库是否存在也很简单，指定一个索引库名就可以了 HotelIndexTest.java1234567@Testvoid existsIndex () throws IOException { ExistsRequest.Builder builder = new ExistsRequest.Builder (); builder.index (&quot;user&quot;); System.out.println (esClient.indices ().exists (builder.build ()).value ());} 文档简单操作elasticsearch 的文档操作比较麻烦，需要单独创建一个 es 文档的 POJO（XXXDoc），这里创建一个 HotelDoc 的 POJO 这结构需要和创建索引库时的结构相同。 我们来分析一下特殊字段该怎么处理（其实也就一个特殊字段）： location 地理位置字段，这里由于 Hotel 原始 POJO 里面并没有这么一个字段，所以我们需要根据 es 中经纬度的写法来转换格式 HotelDoc.java1234567891011121314151617181920212223242526272829303132/** * @author CHENPrime-coder &lt;chenbprime@outlook.com&gt; */@Data@NoArgsConstructorpublic class HotelDoc { private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String location; private String pic; public HotelDoc (Hotel hotel) { this.id = hotel.getId (); this.name = hotel.getName (); this.address = hotel.getAddress (); this.price = hotel.getPrice (); this.score = hotel.getScore (); this.brand = hotel.getBrand (); this.city = hotel.getCity (); this.starName = hotel.getStarName (); this.business = hotel.getBusiness (); this.location = hotel.getLatitude () + &quot;,&quot; + hotel.getLongitude (); this.pic = hotel.getPic (); }} 现在索引库的映射写好了，现在我们需要编写基本的框架 HotelDocumentTest.java1234567891011121314151617181920212223242526272829303132333435363738/** * @author CHENPrime-coder &lt;chenbprime@outlook.com&gt; */@SpringBootTestpublic class HotelDocumentTest { @Autowired private IHotelService service; //es 客户端自动注入 @Autowired static ElasticsearchClient esClient; // 插入文档 @Test void testAddDocument () throws IOException { } // 根据 id 获取文档 @Test void testGetDocumentById () throws IOException { } // 根据 id 更新文档 @Test void testUpdateDocumentById () throws IOException { } // 根据 id 删除文档 @Test void testDeleteDocumentById () throws IOException { } // 批量导入文档 @Test void testBulkDocument () throws IOException { }} 插入文档es 客户端的文档插入操作。我们需要先根据基本的 Hotel 获取 HotelDoc 对象，这里使用封装好的 service 获取 hotel。然后使用 IndexRequest.Builder 构造文档插入请求 HotelDocumentTest.java123456789101112131415161718@Testvoid testAddDocument () throws IOException { Hotel hotel = service.getById (56227L); // 转换为文档类型 HotelDoc doc = new HotelDoc (hotel); // 获取建造器 IndexRequest.Builder&lt;HotelDoc&gt; builder = new IndexRequest.Builder&lt;&gt;(); // 指定索引库名 builder.index (&quot;hotel&quot;); // 设置文档 id builder.id (doc.getId ().toString ()); // 读入文档 builder.document (doc); // 执行插入操作，获取 result 并打印 System.out.println (esClient.index (builder.build ()).result ());} 如果一切正常，那么将会输出如下内容 根据 id 获取文档如果只需要根据 id 获取文档，那么只需要指定索引库名和 id 就行了，下面的删除也是一样。需要注意的是，id 需要是 String 字符串类型。这里需要使用 GetRequest.Builder 建造器 HotelDocumentTest.java1234567891011@Testvoid testGetDocumentById () throws IOException { GetRequest.Builder builder = new GetRequest.Builder (); // 设置索引库名 builder.index (&quot;hotel&quot;); // 设置文档 id builder.id (&quot;36934&quot;); // 传入 GetRequest 设置返回的对象类型 System.out.println (esClient.get (builder.build (), HotelDoc.class).source ());} 获取成功的结果打印： 根据 id 更新文档修改文档有两种方式 方式一：全量更新，再次写入 id 一样的文档，就会删除旧文档，添加新文档 方式二：局部更新，更新部分字段 这里使用第二种方式 更新文档需要使用 UpdateRequest.Builder 建造器，并指定 id 索引库名和文档对象（这里我有一个问题，UpdateRequest.Builder&lt;HotelDoc, HotelDoc&gt; 中的两个泛型分别是什么意思？希望有大佬再评论区指出，感谢） HotelDocumentTest.java1234567891011121314151617181920@Testvoid testUpdateDocumentById () throws IOException { Hotel hotel = service.getById (36934L); // 转换为文档类型 HotelDoc doc = new HotelDoc (hotel); // 修改数据 doc.setName (&quot;修改酒店名字测试&quot;); // 修改的类型 数据类型？ UpdateRequest.Builder&lt;HotelDoc, HotelDoc&gt; builder = new UpdateRequest.Builder&lt;&gt;(); // 设置索引库名 builder.index (&quot;hotel&quot;); // 设置 id builder.id (&quot;36934&quot;); // 读入文档对象 builder.doc (doc); // 执行修改操作 修改类型 获取状态 System.out.println (esClient.update (builder.build (), HotelDoc.class).result ());} 更新成功后的结果打印： 根据 id 删除文档删除文档很简单，指定文档 id 和索引库名就好了。这里就不过多赘述了 HotelDocumentTest.java12345678@Testvoid testDeleteDocumentById () throws IOException { DeleteRequest.Builder builder = new DeleteRequest.Builder (); builder.index (&quot;hotel&quot;); builder.id (&quot;36934&quot;); System.out.println (esClient.delete (builder.build ()).result ());} 删除成功打印： 批量导入文档批量导入文档就需要写一点 lambda 的语法了。其实也不难。只需要遍历然后放入请求建造器就 ok 了 HotelDocumentTest.java123456789101112131415161718192021222324252627@Testvoid testBulkDocument () throws IOException { // 使用 mybatis-plus 获取所有的记录 List&lt;Hotel&gt; list = service.list (); BulkRequest.Builder builder = new BulkRequest.Builder (); // 设置索引库 builder.index (&quot;hotel&quot;); // 遍历记录 for (Hotel hotel : list) { // 添加数据 builder.operations (o -&gt; o //lambda .create (v -&gt; v //lambda // 读入 id .id (hotel.getId ().toString ()) // 读入文档 .document (new HotelDoc (hotel)) // 设置索引库 .index (&quot;hotel&quot;) ) ); } // 执行批量插入，并获取是否发生了错误 System.out.println (esClient.bulk (builder.build ()).errors ());} 批量导入成功打印： 结语由于本人第一次写这样的博客，所以可能有一些地方没有考虑到，希望有大佬可以指出问题。感谢","link":"/elasticsearch-java/"},{"title":"Docker 学习笔记 (1)","text":"Docker 学习笔记 - 命令 docker volume [COMMAND] create 创建一个数据卷 inspect 显示一个或多个数据卷（volume）的详细信息 ls 列出所有 volume prune 删除目前没人使用的数据卷 volume rm 删除指定 volume 代码块测试： HelloWord.java123public static void main (String [] args) { System.out.println (&quot;Hello World!&quot;)}","link":"/docker-cli-1/"}],"tags":[{"name":"微服务","slug":"微服务","link":"/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"运维","slug":"运维","link":"/tags/%E8%BF%90%E7%BB%B4/"}],"categories":[{"name":"elasticsearch","slug":"elasticsearch","link":"/categories/elasticsearch/"},{"name":"docker","slug":"docker","link":"/categories/docker/"}]}